Topics:
    Data I have collected:
        The system cost over time 
        Runtime analysis
    Simulation:
        Samples of what previous sims looked like
        Constraints: I don't have a machine that can run Unreal
    Deadlines:
        I have pretty much until the end of this week if we want to get it done before the end of May. Going to be gone next week.
fix this by taking the entire sum of the system

randomized requests, per time step approval

table of per time step approval runtime 

box and whisker plot, scales with number of requests and number of vertihubs. 

incorporate the data set

to get done today:
    runtime table
    realtime vs static data

What I actually need to get done:
    fix the time-warping. You still have the issue that the TAU graphs exist at different points in time depending on how full their graph is. What you can do is make the TAU graphs all be at the same point in time, and then when you add the TAU to the overall trace, just adjust the requests accordingly. ISSUE is that maybe the swapping algorithm won't account for the fact that you could potentially unviolate a request if you put it in an unoccupied tower. 
    there is also still the issue that the towers don't end up paying for requests fully. to fix this, just go through each trace, and then make the first cost equal to what it would've cost it. For example, if the request is expired

Changes from today (5/27):
    made it so that the towers were correctly accepting their requests before TAU if they were empty -> this fixed the data so that it was far more reasonable

Existing issues:
    time warping when doing the request passing heuristic. described above
    towers not incurring the full cost of expired requests when TAU > 0. 
    Towers sometimes pay for requests that have been swapped away (I believe this is a possibility), actually, someone has to pay this cost. so this may not be an issue

algorithm:
    current_traces <- list per tower
    final_traces <- list per tower
    while there are still existing requests 
        if there are requests for this time step
            TAU_graphs <- list
            for each tower:
                TAU_state <- the first empty state i, or the state at TAU
                time_adjustment <- time step at i or TAU
                for each incoming_request = (requested_port, time_remaining):
                    incoming_request.time_remaining -= time_adjustment
                    TAU_state.append(incoming_request) 
                TAU_graph <- construct a graph with the TAU_state as the initial
                TAU_graphs.append(TAU_graph)
            swapping_heuristic(TAU_graphs)      
            for each tower:
                current_traces[tower] <- current_traces[tower] (from current time step to i or TAU) + TAU_graph
                final_traces[tower].append(current_traces[tower][0])
                del current_traces[tower][0]

swapping heuristic:
    
            
        

